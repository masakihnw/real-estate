name: Update Listings

# このワークフローは物件情報を自動取得し、GitHubにコミット・プッシュします
# セットアップ: リポジトリにこのファイルを配置するだけで動作します

on:
  schedule:
    # 2時間ごとに実行（1日12回）- スクレイピングのみ（Slack通知なし）
    # 元サイトへの負荷はスクレイパー内のレートリミットで制御済み
    - cron: '0 */2 * * *'
    # 毎朝 6:30 JST（21:30 UTC）に実行 - この回のみ Slack 通知を送信
    - cron: '30 21 * * *'
  workflow_dispatch:  # 手動実行も可能（GitHub Actions タブから実行）
    inputs:
      send_slack:
        description: 'Slack通知を送信する（デフォルト: true）'
        required: false
        default: 'true'
        type: choice
        options:
          - 'true'
          - 'false'

# 同時実行を防止: スクレイピング中に別の実行が始まると rebase コンフリクトが起きるため
# 進行中の実行が完了するまで新しい実行はキューで待機させる
concurrency:
  group: update-listings
  cancel-in-progress: false

jobs:
  update:
    runs-on: ubuntu-latest
    permissions:
      contents: write  # コミット・プッシュに必要（リポジトリ設定でも「Read and write」を有効にすること）

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0  # 履歴を全て取得（差分検出のため）

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.9'

      - name: Install dependencies
        working-directory: scraping-tool
        run: |
          pip install -r requirements.txt
          # 東京都地域危険度 GeoJSON 変換用（初回のみ使用、失敗しても続行可能）
          pip install geopandas shapely fiona || echo "geopandas インストール失敗（GeoJSON 変換はスキップ）"
          # 住まいサーフィン ブラウザ自動化用（playwright がインストール済みの場合のみ）
          python3 -c "import playwright" 2>/dev/null && playwright install chromium --with-deps || echo "playwright ブラウザインストールスキップ"

      - name: Run update script
        id: scrape
        working-directory: scraping-tool
        env:
          SUMAI_USER: ${{ secrets.SUMAI_USER }}
          SUMAI_PASS: ${{ secrets.SUMAI_PASS }}
          FIREBASE_SERVICE_ACCOUNT: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}
        run: |
          chmod +x scripts/update_listings.sh
          ./scripts/update_listings.sh --no-git  # レポート・latest/previous まで。コミットは後続ステップで実行

      # パイプライン失敗時もログを Firestore にアップロード（ERR trap が効かないケース用のフォールバック）
      - name: Upload scraping log on failure
        if: failure()
        working-directory: scraping-tool
        env:
          FIREBASE_SERVICE_ACCOUNT: ${{ secrets.FIREBASE_SERVICE_ACCOUNT }}
        run: |
          if [ -f results/scraping_log.txt ]; then
            python3 upload_scraping_log.py results/scraping_log.txt --status error || echo "ログアップロード失敗"
          fi

      # スクリプトで「変更なし」と判断されると早期終了し、latest.json/report を更新しない。
      # その場合 git に変更が残らないため changed=false となり、Slack・コミットはスキップされる。
      - name: Check for changes
        id: check
        run: |
          if git diff --quiet && git diff --cached --quiet; then
            echo "changed=false" >> $GITHUB_OUTPUT
          else
            echo "changed=true" >> $GITHUB_OUTPUT
          fi

      # Slack 通知は 1日1回 朝6:30 JST（21:30 UTC）のみ。手動実行時は inputs.send_slack で制御。
      - name: Check if Slack notification time
        id: slack_time
        run: |
          CURRENT_HOUR=$(date -u +%H)
          CURRENT_MIN=$(date -u +%M)
          echo "Current UTC time: ${CURRENT_HOUR}:${CURRENT_MIN}"
          # 21:25-21:45 UTC（6:25-6:45 JST）の範囲なら Slack 通知タイム
          if [ "$CURRENT_HOUR" = "21" ] && [ "$CURRENT_MIN" -ge 25 ] && [ "$CURRENT_MIN" -le 45 ]; then
            echo "is_slack_time=true" >> $GITHUB_OUTPUT
            echo "→ Slack通知タイム（6:30 JST 前後）"
          elif [ "${{ github.event_name }}" = "workflow_dispatch" ] && [ "${{ github.event.inputs.send_slack }}" != "false" ]; then
            echo "is_slack_time=true" >> $GITHUB_OUTPUT
            echo "→ 手動実行（Slack通知あり）"
          else
            echo "is_slack_time=false" >> $GITHUB_OUTPUT
            echo "→ Slack通知タイム外（スキップ）"
          fi

      - name: Send Slack notification
        if: steps.check.outputs.changed == 'true' && steps.slack_time.outputs.is_slack_time == 'true'
        working-directory: scraping-tool
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          python3 slack_notify.py results/latest.json results/previous.json results/report/report.md

      - name: Commit and push
        if: steps.check.outputs.changed == 'true'
        run: |
          git config --local user.email "action@github.com"
          git config --local user.name "GitHub Action"

          DATE=$(date +%Y%m%d_%H%M%S)
          COUNT=$(python3 -c "import json, pathlib; f=pathlib.Path('scraping-tool/results/latest.json'); print(len(json.load(open(f))) if f.exists() else 0)")

          git add scraping-tool/results/
          [ -f scraping-tool/data/building_units.json ] && git add scraping-tool/data/building_units.json
          [ -f scraping-tool/data/geocode_cache.json ] && git add scraping-tool/data/geocode_cache.json
          [ -f scraping-tool/data/sumai_surfin_cache.json ] && git add scraping-tool/data/sumai_surfin_cache.json
          [ -f scraping-tool/data/reinfolib_prices.json ] && git add scraping-tool/data/reinfolib_prices.json
          [ -f scraping-tool/data/reinfolib_trends.json ] && git add scraping-tool/data/reinfolib_trends.json
          [ -f scraping-tool/data/reinfolib_land_prices.json ] && git add scraping-tool/data/reinfolib_land_prices.json
          [ -f scraping-tool/data/estat_population.json ] && git add scraping-tool/data/estat_population.json
          # 東京都地域危険度 GeoJSON（初回生成時のみ）
          [ -d scraping-tool/results/risk_geojson ] && git add scraping-tool/results/risk_geojson/
          git commit -m "Update listings: ${DATE}

          取得件数: ${COUNT}件
          レポート: scraping-tool/results/report/report.md
          自動更新: GitHub Actions" || exit 0

          # rebase 方式で push（コンフリクト時は最新の実行結果を優先）
          # rebase 失敗時は abort → merge --strategy=ours で確実に push する
          if git pull --rebase -X theirs origin ${{ github.ref_name }}; then
            git push origin HEAD:refs/heads/${{ github.ref_name }}
          else
            echo "rebase 失敗: merge 方式にフォールバック" >&2
            git rebase --abort
            git pull --no-rebase -X ours origin ${{ github.ref_name }}
            git push origin HEAD:refs/heads/${{ github.ref_name }}
          fi

      # ワークフロー失敗時に Slack で通知（SLACK_WEBHOOK_URL が設定されている場合のみ）
      - name: Notify failure to Slack
        if: failure()
        env:
          SLACK_WEBHOOK_URL: ${{ secrets.SLACK_WEBHOOK_URL }}
        run: |
          if [ -n "$SLACK_WEBHOOK_URL" ]; then
            curl -s -X POST "$SLACK_WEBHOOK_URL" \
              -H 'Content-type: application/json' \
              -d "{\"text\": \":rotating_light: *物件スクレイピング失敗*\nワークフロー: ${{ github.workflow }}\n実行: ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}\"}"
          fi
