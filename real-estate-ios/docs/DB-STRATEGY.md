# 物件アプリ DB 設計方針

保守性・UX・「サクサク動く」を満たすための DB の持ち方と同期方針。

---

## 結論（推奨）

| 観点 | 方針 |
|------|------|
| **どこに持つか** | アプリ内のみ（SwiftData）。Notion 連携は行わない。 |
| **同期** | 単一ソース（一覧 JSON URL）から **フル置き換え**。同一物件は `identityKey` でマッチして更新、新規は挿入、一覧から消えたものはローカルから削除。 |
| **パフォーマンス** | SwiftData の `@Query` でリストは遅延評価。ソート・検索はメモリ上でフィルタ（件数が数千までなら十分速い）。必要なら後から `FetchDescriptor` の predicate でサーバ側フィルタ相当を追加。 |
| **保守** | スキーマ変更は SwiftData のマイグレーション（`VersionedSchema` / `SchemaMigrationPlan`）で管理。バックエンド不要で運用コスト最小。 |

---

## 1. 保守観点

### 1.1 アプリ内 DB のみ（SwiftData）にする理由

- **運用コスト**: サーバー・API を立てないため、障害対応・デプロイ・認証の保守が不要。
- **単一責任**: データの「真実のソース」は「一覧 JSON を配信している URL」だけ。アプリはそのスナップショットをローカルに持つだけ。
- **Notion は使わない**: 今回のアプリでは Notion 連携は行わず、元々 Notion でやっていた DB 機能をアプリに寄せる。データは JSON URL → アプリの SwiftData のみ。

### 1.2 スキーマ変更

- プロパティ追加・削除・型変更は SwiftData の **VersionedSchema** と **SchemaMigrationPlan** で扱う。
- 初回リリースはバージョン 1 のみ。将来プロパティを足すときは `SchemaV2` を追加し、軽量マイグレーション（再取得で上書きするだけでも可）で対応。

### 1.3 データの流れ

```
[JSON 配信 URL] → アプリが GET → パース → SwiftData に反映
                    ↑
                    （設定で保存した URL、例: GitHub raw）
```

- バックエンドは不要。既存の scraping-tool が生成した `latest.json` を GitHub 等で配信し、その URL を設定すればよい。

---

## 2. UX 観点

### 2.1 ローカルファースト

- 一覧・詳細は **常にローカル DB から表示**。ネットワークがなくても一覧・詳細は見られる。
- 「更新」はプルで手動実行 or バックグラウンド更新（将来）で、取得結果でローカルを更新する。

### 2.2 更新の分かりやすさ

- **最終更新日時**を一覧・設定の両方で表示し、「いつ時点のデータか」を明示する。
- 更新中はプログレス表示。エラー時は設定タブや一覧のツールバーで短く表示（HIG に沿った控えめなフィードバック）。

### 2.3 新規物件の通知

- 更新処理の結果「新規」が検出されたら **ローカル通知** で「○件の新規物件が追加されました」と出す。リモートプッシュは Phase 2（バックエンドを用意する場合）で検討。

---

## 3. サクサク動かすため（パフォーマンス）

### 3.1 一覧

- **@Query** で SwiftData がクエリを最適化し、必要な分だけフェッチする。全件を一度にメモリに載せない。
- リストのセルは **軽く保つ**: テキストとシステムアイコンのみ。画像は使わない（将来サムネイルを足す場合は LazyLoading やキャッシュを検討）。
- ソートは現状メモリ上で実施。件数が数千程度なら問題にならない。それ以上になる場合は `FetchDescriptor` の `sortBy` で DB 側ソートに寄せる。

### 3.2 検索

- 検索は `@Query` で取った結果をメモリ上でフィルタ。同じ理由で数千件までなら十分速い。
- 将来的に件数が膨大になった場合は、`FetchDescriptor` に predicate（例: 名前・住所の contains）を付け、DB 側で絞り込む形に変更可能。

### 3.3 同期処理

- 同期は **メインスレッドをブロックしない**（すでに `async` で実装）。UI は `isRefreshing` でローディング表示。
- 差分計算（新規・更新・削除）は 1 回の fetch と 1 回のループで完結させ、無駄な N+1 や重い処理を避ける。

### 3.4 インデックス（将来）

- SwiftData では `@Attribute(.unique)` やインデックスを付与できる。現状は `url` を実質キーにしているので、必要に応じてユニーク制約を付けると重複防止と検索の安定性が上がる。

---

## 4. まとめ

- **DB**: アプリ内のみ（SwiftData）。Notion は使わない。
- **同期**: 一覧 JSON URL からフル同期（同一は更新、新規は挿入、消えたものは削除）。
- **保守**: スキーマは VersionedSchema で管理。サーバー不要。
- **UX**: ローカルファースト、最終更新の明示、新規はローカル通知。
- **パフォーマンス**: @Query の遅延評価、軽いセル、非同期更新で「サクサク」を維持。

この方針で実装し、必要に応じて FetchDescriptor の predicate / sortBy や SwiftData のインデックスでチューニングする。
